<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>Unicorn Library: Command Line Options</title>
	<link type="text/css" rel="stylesheet" href="style.css"/>
</head>
<body>

<h1 id="unicornlibrary:commandlineoptions"><a href="index.html">Unicorn Library</a>: Command Line Options</h1>

<h4 id="unicodelibraryforcbyrosssmith">Unicode library for C++ by Ross Smith</h4>

<h4 id="includeunicornoptions.hpp"><code>#include &quot;unicorn/options.hpp&quot;</code></h4>

<p>The <code>Options</code> class defined in this module handles parsing of command line
options. It provides commonly used features such as coalescing of single
character options (e.g. <code>-abc</code> vs <code>-a -b -c</code>), long option names (e.g.
<code>--long-option</code>), and so on.</p>

<p>This module calls the <a href="regex.html"><code>unicorn/regex</code></a> module, which in turn
calls the PCRE library. It will only work with encodings for which the
corresponding PCRE library has been linked; see the regex module documentation
for details.</p>
<p class="alert">[TODO: DOCUMENTATION]</p>

<h2 id="contents">Contents</h2>

<ul>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#optionsparsingclass">Options parsing class</a></li>
</ul>

<h2 id="exceptions">Exceptions</h2>

<ul>
<li><code>class <strong>CommandLineError</strong>: public std::runtime_error</code>

<ul>
<li><code>explicit CommandLineError::<strong>CommandLineError</strong>(const u8string&amp; details, const u8string&amp; arg1 = {}, const u8string&amp; arg2 = {})</code></li>
</ul></li>
<li><code>class <strong>OptionSpecError</strong>: public std::runtime_error</code>

<ul>
<li><code>explicit OptionSpecError::<strong>OptionSpecError</strong>(const u8string&amp; details, const u8string&amp; option = {})</code></li>
</ul></li>
</ul>

<p>TODO</p>

<h2 id="optionsparsingclass">Options parsing class</h2>

<ul>
<li><code>class <strong>Options</strong></code></li>
</ul>

<p>TODO</p>

<ul>
<li><code>template &lt;typename C&gt; explicit Options::<strong>Options</strong>(const basic_string&lt;C&gt;&amp; info, const basic_string&lt;C&gt;&amp; head = {}, const basic_string&lt;C&gt;&amp; tail = {})</code></li>
<li><code>template &lt;typename C&gt; explicit Options::<strong>Options</strong>(const C* info, const C* head = nullptr, const C* tail = nullptr)</code></li>
<li><code>Options::<strong>Options</strong>(const Options&amp; opt)</code></li>
<li><code>Options::<strong>Options</strong>(Options&amp;&amp; opt)</code></li>
<li><code>Options::<strong>~Options</strong>()</code></li>
<li><code>Options&amp; Options::<strong>operator=</strong>(const Options&amp; opt)</code></li>
<li><code>Options&amp; Options::<strong>operator=</strong>(Options&amp;&amp; opt)</code></li>
</ul>

<p>TODO</p>

<ul>
<li><code>template &lt;typename C&gt; void Options::<strong>add</strong>(const basic_string&lt;C&gt;&amp; name, C abbrev, const basic_string&lt;C&gt;&amp; info, Crow::Flagset flags = {}, const basic_string&lt;C&gt;&amp; defval = {}, const basic_string&lt;C&gt;&amp; pattern = {}, const basic_string&lt;C&gt;&amp; group = {})</code></li>
<li><code>template &lt;typename C&gt; void Options::<strong>add</strong>(const C* name, C abbrev, const C* info, Crow::Flagset flags = {}, const C* defval = {}, const C* pattern = {}, const C* group = {})</code></li>
</ul>

<p>TODO</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Bitmask</th>
	<th style="text-align:left;">Letter</th>
	<th style="text-align:left;">Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;"><code>opt_anon</code></td>
	<td style="text-align:left;"><code>a</code></td>
	<td style="text-align:left;">Assign anonymous arguments to this option</td>
</tr>
<tr>
	<td style="text-align:left;"><code>opt_boolean</code></td>
	<td style="text-align:left;"><code>b</code></td>
	<td style="text-align:left;">Boolean option</td>
</tr>
<tr>
	<td style="text-align:left;"><code>opt_float</code></td>
	<td style="text-align:left;"><code>f</code></td>
	<td style="text-align:left;">Argument must be a floating point number</td>
</tr>
<tr>
	<td style="text-align:left;"><code>opt_integer</code></td>
	<td style="text-align:left;"><code>i</code></td>
	<td style="text-align:left;">Argument must be an integer</td>
</tr>
<tr>
	<td style="text-align:left;"><code>opt_multiple</code></td>
	<td style="text-align:left;"><code>m</code></td>
	<td style="text-align:left;">Option may have multiple arguments</td>
</tr>
<tr>
	<td style="text-align:left;"><code>opt_required</code></td>
	<td style="text-align:left;"><code>r</code></td>
	<td style="text-align:left;">Option is required</td>
</tr>
</tbody>
</table>

<p>TODO</p>

<ul>
<li><code>void Options::<strong>autohelp</strong>() noexcept</code></li>
</ul>

<p>TODO</p>

<ul>
<li><code>u8string Options::<strong>help</strong>() const</code></li>
<li><code>u8string Options::<strong>version</strong>() const</code></li>
</ul>

<p>TODO</p>

<ul>
<li><code>template &lt;typename C&gt; bool Options::<strong>parse</strong>(const std::vector&lt;basic_string&lt;C&gt;&gt;&amp; args)</code></li>
<li><code>template &lt;typename C1, typename C2&gt; bool Options::<strong>parse</strong>(const std::vector&lt;basic_string&lt;C1&gt;&gt;&amp; args, std::basic_ostream&lt;C2&gt;&amp; out, Crow::Flagset flags = {})</code></li>
<li><code>template &lt;typename C&gt; bool Options::<strong>parse</strong>(const basic_string&lt;C&gt;&amp; args)</code></li>
<li><code>template &lt;typename C1, typename C2&gt; bool Options::<strong>parse</strong>(const basic_string&lt;C1&gt;&amp; args, std::basic_ostream&lt;C2&gt;&amp; out, Crow::Flagset flags = {})</code></li>
<li><code>template &lt;typename C&gt; bool Options::<strong>parse</strong>(int argc, C** argv)</code></li>
<li><code>template &lt;typename C1, typename C2&gt; bool Options::<strong>parse</strong>(int argc, C1** argv, std::basic_ostream&lt;C2&gt;&amp; out, Crow::Flagset flags = {})</code></li>
</ul>

<p>TODO</p>

<table>
<colgroup>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
<col style="text-align:left;"/>
</colgroup>

<thead>
<tr>
	<th style="text-align:left;">Bitmask</th>
	<th style="text-align:left;">Letter</th>
	<th style="text-align:left;">Description</th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;"><code>opt_locale</code></td>
	<td style="text-align:left;"><code>l</code></td>
	<td style="text-align:left;">Argument list is in local encoding (ignored if C[1] is not char)</td>
</tr>
<tr>
	<td style="text-align:left;"><code>opt_noprefix</code></td>
	<td style="text-align:left;"><code>n</code></td>
	<td style="text-align:left;">First argument is not the command name</td>
</tr>
<tr>
	<td style="text-align:left;"><code>opt_quoted</code></td>
	<td style="text-align:left;"><code>q</code></td>
	<td style="text-align:left;">Allow arguments to be quoted</td>
</tr>
</tbody>
</table>

<p>TODO</p>

<ul>
<li><code>template &lt;typename C&gt; bool Options::<strong>has</strong>(const basic_string&lt;C&gt;&amp; name) const</code></li>
<li><code>template &lt;typename C&gt; bool Options::<strong>has</strong>(const C* name) const</code></li>
</ul>

<p>TODO</p>

<ul>
<li><code>template &lt;typename T, typename C&gt; T Options::<strong>get</strong>(const basic_string&lt;C&gt;&amp; name) const</code></li>
<li><code>template &lt;typename T, typename C&gt; T Options::<strong>get</strong>(const C* name) const</code></li>
</ul>

<p>TODO</p>

<ul>
<li><code>template &lt;typename T, typename C&gt; std::vector&lt;T&gt; Options::<strong>getlist</strong>(const basic_string&lt;C&gt;&amp; name) const</code></li>
<li><code>template &lt;typename T, typename C&gt; std::vector&lt;T&gt; Options::<strong>getlist</strong>(const C* name) const</code></li>
</ul>

<p>TODO</p>

</body>
</html>
